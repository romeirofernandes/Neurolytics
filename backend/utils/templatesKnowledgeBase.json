[
  {
    "id": "stroop",
    "name": "Stroop Task",
    "fullName": "Stroop Color-Word Task",
    "shortDescription": "Measures selective attention, processing speed, and cognitive control",
    "category": "Cognitive Control",
    "difficulty": "Beginner",
    "duration": "~1-2 minutes",
    "trials": "20 trials (5 training)",
    "measures": ["Selective attention", "Response inhibition", "Processing speed", "Stroop effect magnitude"],
    "keywords": ["stroop", "attention", "cognitive control", "interference", "executive function", "color", "word"],
    "requiresCamera": false,
    "codePattern": "useState for word/color, useEffect for keyboard, color-word conflict, RT measurement",
    "keyFeatures": [
      "Training and main trials",
      "Keyboard shortcuts (R, G, B, Y)",
      "Compatible/incompatible trials",
      "Reaction time tracking",
      "Visual color display"
    ],
    "code": "import { useState, useEffect } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\n\nexport const StroopTemplate = ({ onComplete }) => {\n  const [currentTrial, setCurrentTrial] = useState(0);\n  const [word, setWord] = useState('');\n  const [color, setColor] = useState('');\n  const [startTime, setStartTime] = useState(0);\n  const [results, setResults] = useState([]);\n  const [isTraining, setIsTraining] = useState(true);\n\n  const words = ['RED', 'GREEN', 'BLUE', 'YELLOW'];\n  const colors = { RED: 'red', GREEN: 'green', BLUE: 'blue', YELLOW: 'yellow' };\n  const keys = { r: 'RED', g: 'GREEN', b: 'BLUE', y: 'YELLOW' };\n\n  useEffect(() => {\n    generateTrial();\n  }, []);\n\n  useEffect(() => {\n    const handleKeyPress = (e) => {\n      if (keys[e.key.toLowerCase()]) {\n        handleResponse(keys[e.key.toLowerCase()]);\n      }\n    };\n    window.addEventListener('keydown', handleKeyPress);\n    return () => window.removeEventListener('keydown', handleKeyPress);\n  }, [word, color, startTime]);\n\n  const generateTrial = () => {\n    const newWord = words[Math.floor(Math.random() * words.length)];\n    const newColor = words[Math.floor(Math.random() * words.length)];\n    setWord(newWord);\n    setColor(newColor);\n    setStartTime(Date.now());\n  };\n\n  const handleResponse = (response) => {\n    const rt = Date.now() - startTime;\n    const correct = response === color;\n    const compatible = word === color ? 1 : 0;\n    const result = { word, color, compatible, response, correct: correct ? 1 : 0, rt };\n    setResults([...results, result]);\n\n    const nextTrial = currentTrial + 1;\n    if (isTraining && nextTrial >= 5) {\n      setIsTraining(false);\n      setCurrentTrial(0);\n      generateTrial();\n    } else if (!isTraining && nextTrial >= 20) {\n      onComplete?.(results);\n    } else {\n      setCurrentTrial(nextTrial);\n      generateTrial();\n    }\n  };\n\n  return (\n    <Card className=\"w-full max-w-2xl mx-auto\">\n      <CardHeader>\n        <CardTitle>Stroop Task</CardTitle>\n        <CardDescription>{isTraining ? 'Training Mode' : `Trial ${currentTrial + 1} of 20`}</CardDescription>\n      </CardHeader>\n      <CardContent className=\"space-y-6\">\n        <div className=\"text-center text-sm text-muted-foreground\">Press the key corresponding to the COLOR of the word (not what it says)</div>\n        <div className=\"flex justify-center items-center h-64\">\n          <div className=\"text-6xl font-bold\" style={{ color: colors[color] }}>{word}</div>\n        </div>\n        <div className=\"grid grid-cols-4 gap-2\">\n          {Object.entries(colors).map(([name, colorValue]) => (\n            <Button key={name} onClick={() => handleResponse(name)} style={{ backgroundColor: colorValue }} className=\"text-white\">{name[0]}</Button>\n          ))}\n        </div>\n        <div className=\"text-center text-xs text-muted-foreground\">Keyboard shortcuts: R, G, B, Y</div>\n      </CardContent>\n    </Card>\n  );\n};"
  },
  {
    "id": "bart",
    "name": "BART",
    "fullName": "Balloon Analogue Risk Task",
    "shortDescription": "Measures risk-taking behavior and decision-making under uncertainty",
    "category": "Decision Making",
    "difficulty": "Beginner",
    "duration": "~2 minutes",
    "trials": "33 trials (3 training)",
    "measures": ["Risk-taking propensity", "Reward sensitivity", "Decision-making strategy"],
    "keywords": ["risk", "decision-making", "reward", "gambling", "impulse control", "balloon"],
    "requiresCamera": false,
    "codePattern": "Dynamic balloon sizing, risk-reward tradeoff, explosion probability, earnings tracking",
    "keyFeatures": [
      "Balloon pumping mechanic",
      "Variable explosion points",
      "Training trials",
      "Earnings calculation",
      "Different colored balloons"
    ],
    "code": "import { useState, useEffect } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\n\nexport const BARTTemplate = ({ onComplete }) => {\n  const [balloonSize, setBalloonSize] = useState(50);\n  const [pumps, setPumps] = useState(0);\n  const [earnings, setEarnings] = useState(0);\n  const [currentEarnings, setCurrentEarnings] = useState(0);\n  const [balloonColor, setBalloonColor] = useState('blue');\n  const [balloonCount, setBalloonCount] = useState(1);\n  const [exploded, setExploded] = useState(false);\n  const [results, setResults] = useState([]);\n  const [isTraining, setIsTraining] = useState(true);\n  const [maxPumps, setMaxPumps] = useState(10);\n\n  const balloonColors = { blue: { color: '#3B82F6', maxAvg: 64 }, yellow: { color: '#EAB308', maxAvg: 16 }, orange: { color: '#F97316', maxAvg: 4 }, green: { color: '#22C55E', maxAvg: 10 } };\n\n  useEffect(() => { resetBalloon(); }, []);\n\n  const resetBalloon = () => {\n    const colors = isTraining ? ['green'] : ['blue', 'yellow', 'orange'];\n    const newColor = colors[Math.floor(Math.random() * colors.length)];\n    const avgMax = balloonColors[newColor].maxAvg;\n    const newMax = Math.floor(avgMax * (0.5 + Math.random()));\n    setBalloonColor(newColor);\n    setMaxPumps(newMax);\n    setBalloonSize(50);\n    setPumps(0);\n    setCurrentEarnings(0);\n    setExploded(false);\n  };\n\n  const handlePump = () => {\n    if (exploded) return;\n    const newPumps = pumps + 1;\n    const newEarnings = currentEarnings + 0.05;\n    setPumps(newPumps);\n    setCurrentEarnings(newEarnings);\n    setBalloonSize(50 + newPumps * 10);\n    if (newPumps >= maxPumps) {\n      setExploded(true);\n      setResults([...results, { balloonColor, balloonCount, timesPumped: newPumps, explosion: 1, earningsThisBalloon: 0, totalEarnings: earnings }]);\n      setTimeout(() => {\n        if (balloonCount >= 33) { onComplete?.(results); } else { setBalloonCount(balloonCount + 1); if (isTraining && balloonCount >= 3) { setIsTraining(false); } resetBalloon(); }\n      }, 1000);\n    }\n  };\n\n  const handleCollect = () => {\n    if (exploded) return;\n    const newEarnings = earnings + currentEarnings;\n    setEarnings(newEarnings);\n    setResults([...results, { balloonColor, balloonCount, timesPumped: pumps, explosion: 0, earningsThisBalloon: currentEarnings, totalEarnings: newEarnings }]);\n    if (balloonCount >= 33) { onComplete?.(results); } else { setBalloonCount(balloonCount + 1); if (isTraining && balloonCount >= 3) { setIsTraining(false); } resetBalloon(); }\n  };\n\n  return (\n    <Card className=\"w-full max-w-2xl mx-auto\">\n      <CardHeader><CardTitle>Balloon Analogue Risk Task (BART)</CardTitle><CardDescription>{isTraining ? 'Training Mode' : `Trial ${balloonCount - 3} of 30`}</CardDescription></CardHeader>\n      <CardContent className=\"space-y-4\">\n        <div className=\"flex justify-between text-sm\"><div>Current Trial: ${currentEarnings.toFixed(2)}</div><div>Total Earnings: ${earnings.toFixed(2)}</div></div>\n        <div className=\"flex justify-center items-center h-96 relative\"><div className=\"rounded-full transition-all duration-200\" style={{ width: `${balloonSize}px`, height: `${balloonSize}px`, backgroundColor: exploded ? '#EF4444' : balloonColors[balloonColor].color, opacity: exploded ? 0.5 : 1 }}>{exploded && <div className=\"flex items-center justify-center h-full text-white font-bold text-2xl\">ðŸ’¥ POP!</div>}</div></div>\n        <div className=\"flex gap-4 justify-center\"><Button onClick={handlePump} disabled={exploded} size=\"lg\">Pump (+$0.05)</Button><Button onClick={handleCollect} disabled={exploded} variant=\"outline\" size=\"lg\">Collect Money</Button></div>\n        <div className=\"text-center text-sm text-muted-foreground\">Pumps: {pumps}</div>\n      </CardContent>\n    </Card>\n  );\n};"
  },
  {
    "id": "flanker",
    "name": "Flanker Task",
    "fullName": "Eriksen Flanker Task",
    "shortDescription": "Measures selective attention and response inhibition",
    "category": "Attention",
    "difficulty": "Beginner",
    "duration": "~1-2 minutes",
    "trials": "20 trials (5 training)",
    "measures": ["Selective attention", "Cognitive control", "Interference suppression", "Flanker effect"],
    "keywords": ["flanker", "attention", "interference", "cognitive control", "selective attention", "distractor"],
    "requiresCamera": false,
    "codePattern": "Congruent/incongruent trials, fixation-stimulus-feedback phases, keyboard A/L responses, target letter identification",
    "keyFeatures": [
      "Target letter with flankers (e.g., HHSHH)",
      "Compatible/incompatible conditions",
      "Fixation cross presentation",
      "Keyboard response (A for left, L for right)",
      "Feedback display"
    ],
    "code": "import { useState, useEffect } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\n\nexport const FlankerTemplate = ({ onComplete }) => {\n  const [currentTrial, setCurrentTrial] = useState(0);\n  const [stimulus, setStimulus] = useState('');\n  const [congruent, setCongruent] = useState(true);\n  const [targetLetter, setTargetLetter] = useState('');\n  const [phase, setPhase] = useState('fixation');\n  const [startTime, setStartTime] = useState(0);\n  const [results, setResults] = useState([]);\n  const [isTraining, setIsTraining] = useState(true);\n  const [feedback, setFeedback] = useState('');\n  const [showReminder, setShowReminder] = useState(false);\n\n  const leftLetters = ['X', 'C'];\n  const rightLetters = ['V', 'B'];\n  const allLetters = [...leftLetters, ...rightLetters];\n\n  useEffect(() => { startTrial(); }, [currentTrial]);\n  useEffect(() => {\n    const handleKeyPress = (e) => { if (phase === 'stimulus' && (e.key === 'a' || e.key === 'l')) { handleResponse(e.key); } };\n    window.addEventListener('keydown', handleKeyPress);\n    return () => window.removeEventListener('keydown', handleKeyPress);\n  }, [phase, stimulus, startTime]);\n\n  const startTrial = () => {\n    const totalTrials = isTraining ? 5 : 20;\n    if (currentTrial >= totalTrials) { if (isTraining) { setIsTraining(false); setCurrentTrial(0); return; } else { onComplete?.(results); return; } }\n    setPhase('fixation');\n    setFeedback('');\n    const isCongruent = Math.random() < 0.5;\n    const target = allLetters[Math.floor(Math.random() * allLetters.length)];\n    let flankers = isCongruent ? target : (leftLetters.includes(target) ? leftLetters : rightLetters).find(l => l !== target) || target;\n    const stimulusString = `${flankers}${flankers}${target}${flankers}${flankers}`;\n    setStimulus(stimulusString);\n    setCongruent(isCongruent);\n    setTargetLetter(target);\n    setTimeout(() => { setPhase('stimulus'); setStartTime(Date.now()); setTimeout(() => { if (phase === 'stimulus') { handleResponse(null); } }, 2000); }, 500);\n  };\n\n  const handleResponse = (key) => {\n    if (phase !== 'stimulus') return;\n    const rt = Date.now() - startTime;\n    const correctKey = leftLetters.includes(targetLetter) ? 'a' : 'l';\n    const correct = key === correctKey;\n    const status = !key ? 3 : (correct ? 1 : 2);\n    const result = { stimulus, congruent: congruent ? 1 : 0, targetLetter, response: key || 'timeout', correct: correct ? 1 : 0, status, rt: key ? rt : 2000 };\n    setResults([...results, result]);\n    setPhase('feedback');\n    if (status === 1) { setFeedback('âœ“ Correct'); } else if (status === 2) { setFeedback('âœ— Error - Remember the rules!'); setShowReminder(true); setTimeout(() => setShowReminder(false), 2000); } else { setFeedback('Too slow!'); }\n    setTimeout(() => { setCurrentTrial(currentTrial + 1); }, status === 2 ? 2500 : 800);\n  };\n\n  const getInstructions = () => (\n    <div className=\"space-y-2 text-sm\"><p className=\"font-semibold\">Press the key for the MIDDLE letter:</p><div className=\"grid grid-cols-2 gap-2 text-xs\"><div className=\"bg-blue-100 dark:bg-blue-900 p-2 rounded\"><strong>A key (Left):</strong> X or C</div><div className=\"bg-green-100 dark:bg-green-900 p-2 rounded\"><strong>L key (Right):</strong> V or B</div></div><p className=\"text-xs text-muted-foreground\">Ignore the flanking letters!</p></div>\n  );\n\n  return (\n    <Card className=\"w-full max-w-2xl mx-auto\">\n      <CardHeader><CardTitle>Flanker Task (Eriksen)</CardTitle><CardDescription>{isTraining ? `Training Trial ${currentTrial + 1} of 5` : `Trial ${currentTrial + 1} of 20`}</CardDescription></CardHeader>\n      <CardContent className=\"space-y-6\">\n        {getInstructions()}\n        <div className=\"flex flex-col items-center justify-center h-64 relative\">\n          {phase === 'fixation' && <div className=\"text-6xl font-bold\">+</div>}\n          {phase === 'stimulus' && <div className=\"space-y-4 text-center\"><div className=\"text-6xl font-mono font-bold tracking-wider\">{stimulus}</div><div className=\"text-xs text-muted-foreground\">Respond to the middle letter!</div></div>}\n          {phase === 'feedback' && feedback && <div className={`text-2xl font-bold ${feedback.includes('âœ“') ? 'text-green-600' : 'text-red-600'}`}>{feedback}</div>}\n        </div>\n        {showReminder && <div className=\"bg-yellow-100 dark:bg-yellow-900 border border-yellow-400 rounded p-3\">{getInstructions()}</div>}\n        <div className=\"text-center text-xs text-muted-foreground\">{isTraining ? 'ðŸŽ“ Training Mode - Practice makes perfect!' : 'ðŸ“Š Main Experiment'}</div>\n      </CardContent>\n    </Card>\n  );\n};"
  },
  {
    "id": "posner",
    "name": "Posner Cueing",
    "fullName": "Posner Spatial Cueing Task",
    "shortDescription": "Assesses spatial attention orienting and visual processing",
    "category": "Attention",
    "difficulty": "Intermediate",
    "duration": "~2 minutes",
    "trials": "40 trials",
    "measures": ["Spatial attention", "Cueing effects", "Attentional orienting", "Response time benefits"],
    "keywords": ["posner", "attention", "cueing", "spatial attention", "orienting", "cue", "target"],
    "requiresCamera": false,
    "codePattern": "Valid/invalid cue paradigm, spatial boxes, fixation-cue-target sequence, A/L keyboard responses",
    "keyFeatures": [
      "Left/right spatial boxes",
      "Cue presentation (X marker)",
      "Valid (75%) and invalid cues",
      "Target presentation (GO stimulus)",
      "Keyboard response (A/L)"
    ],
    "code": "import { useState, useEffect } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\n\nexport const PosnerTemplate = ({ onComplete }) => {\n  const [currentTrial, setCurrentTrial] = useState(0);\n  const [phase, setPhase] = useState('fixation');\n  const [cuePosition, setCuePosition] = useState('left');\n  const [targetPosition, setTargetPosition] = useState('left');\n  const [startTime, setStartTime] = useState(0);\n  const [results, setResults] = useState([]);\n\n  useEffect(() => { startTrial(); }, [currentTrial]);\n  useEffect(() => {\n    const handleKeyPress = (e) => { if (phase === 'target' && (e.key === 'a' || e.key === 'l')) { handleResponse(e.key === 'a' ? 'left' : 'right'); } };\n    window.addEventListener('keydown', handleKeyPress);\n    return () => window.removeEventListener('keydown', handleKeyPress);\n  }, [phase, startTime]);\n\n  const startTrial = () => {\n    if (currentTrial >= 40) { onComplete?.(results); return; }\n    const isValidCue = Math.random() < 0.75;\n    const cue = Math.random() < 0.5 ? 'left' : 'right';\n    const target = isValidCue ? cue : (cue === 'left' ? 'right' : 'left');\n    setCuePosition(cue);\n    setTargetPosition(target);\n    setPhase('fixation');\n    setTimeout(() => { setPhase('cue'); setTimeout(() => { setPhase('target'); setStartTime(Date.now()); }, 150); }, 1000);\n  };\n\n  const handleResponse = (response) => {\n    const rt = Date.now() - startTime;\n    const correct = response === targetPosition;\n    const valid = cuePosition === targetPosition ? 1 : 0;\n    setResults([...results, { cuePosition, targetPosition, valid, response, correct: correct ? 1 : 0, rt }]);\n    setCurrentTrial(currentTrial + 1);\n  };\n\n  return (\n    <Card className=\"w-full max-w-2xl mx-auto\">\n      <CardHeader><CardTitle>Posner Cueing Task</CardTitle><CardDescription>Trial {currentTrial + 1} of 40</CardDescription></CardHeader>\n      <CardContent>\n        <div className=\"text-center text-sm text-muted-foreground mb-6\">Press 'A' for left box, 'L' for right box when you see GO</div>\n        <div className=\"flex justify-center gap-8 h-64 items-center\">\n          <div className=\"w-32 h-32 border-4 border-yellow-400 relative flex items-center justify-center\">{phase === 'cue' && cuePosition === 'left' && <div className=\"text-4xl font-bold\">X</div>}{phase === 'target' && targetPosition === 'left' && <div className=\"w-24 h-24 rounded-full bg-green-500 flex items-center justify-center text-white font-bold\">GO</div>}</div>\n          <div className=\"w-32 h-32 border-4 border-yellow-400 relative flex items-center justify-center\">{phase === 'cue' && cuePosition === 'right' && <div className=\"text-4xl font-bold\">X</div>}{phase === 'target' && targetPosition === 'right' && <div className=\"w-24 h-24 rounded-full bg-green-500 flex items-center justify-center text-white font-bold\">GO</div>}</div>\n        </div>\n      </CardContent>\n    </Card>\n  );\n};"
  },
  {
    "id": "gonogo",
    "name": "Go/No-Go",
    "fullName": "Go/No-Go Inhibition Task",
    "shortDescription": "Measures response inhibition and impulse control",
    "category": "Executive Function",
    "difficulty": "Beginner",
    "duration": "~1-2 minutes",
    "trials": "30 trials",
    "measures": ["Response inhibition", "Impulse control", "Commission errors", "Reaction time"],
    "keywords": ["go no-go", "inhibition", "impulse control", "executive function", "self-control", "stop"],
    "requiresCamera": false,
    "codePattern": "Go/No-Go trials (80/20), spacebar response, commission/omission errors, variable fixation",
    "keyFeatures": [
      "80% Go trials, 20% No-Go trials",
      "Spacebar response for Go",
      "Withhold response for No-Go",
      "Variable fixation duration",
      "Error tracking"
    ],
    "code": "import { useState, useEffect } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\n\nexport const GoNoGoTemplate = ({ onComplete }) => {\n  const [currentTrial, setCurrentTrial] = useState(0);\n  const [trialType, setTrialType] = useState('go');\n  const [phase, setPhase] = useState('fixation');\n  const [startTime, setStartTime] = useState(0);\n  const [results, setResults] = useState([]);\n  const [feedback, setFeedback] = useState('');\n  const [responded, setResponded] = useState(false);\n\n  const totalTrials = 30;\n\n  useEffect(() => { startTrial(); }, [currentTrial]);\n  useEffect(() => {\n    const handleKeyPress = (e) => { if (phase === 'stimulus' && e.key === ' ' && !responded) { setResponded(true); handleResponse(); } };\n    window.addEventListener('keydown', handleKeyPress);\n    return () => window.removeEventListener('keydown', handleKeyPress);\n  }, [phase, responded]);\n\n  const startTrial = () => {\n    if (currentTrial >= totalTrials) { onComplete?.(results); return; }\n    setPhase('fixation');\n    setFeedback('');\n    setResponded(false);\n    const isGoTrial = Math.random() < 0.8;\n    setTrialType(isGoTrial ? 'go' : 'nogo');\n    setTimeout(() => { setPhase('stimulus'); setStartTime(Date.now()); setTimeout(() => { if (!responded) { handleTimeout(); } }, 2000); }, 500 + Math.random() * 500);\n  };\n\n  const handleResponse = () => {\n    const rt = Date.now() - startTime;\n    const isError = trialType === 'nogo';\n    const result = { trialType, rt, error: isError ? 1 : 0, status: isError ? 2 : 1 };\n    setResults([...results, result]);\n    setPhase('feedback');\n    if (isError) { setFeedback('âœ— Error - You should NOT press on No-Go!'); } else { setFeedback('âœ“ Correct - Good reaction!'); }\n    setTimeout(() => { setCurrentTrial(currentTrial + 1); }, 600);\n  };\n\n  const handleTimeout = () => {\n    const isError = trialType === 'go';\n    const result = { trialType, rt: 2000, error: isError ? 1 : 0, status: isError ? 3 : 1 };\n    setResults([...results, result]);\n    setPhase('feedback');\n    if (isError) { setFeedback('âœ— Too Slow - Press quickly on Go!'); } else { setFeedback('âœ“ Correct - Well done withholding!'); }\n    setTimeout(() => { setCurrentTrial(currentTrial + 1); }, 600);\n  };\n\n  return (\n    <Card className=\"w-full max-w-2xl mx-auto\">\n      <CardHeader><CardTitle>Go/No-Go Task</CardTitle><CardDescription>Trial {currentTrial + 1} of {totalTrials}</CardDescription></CardHeader>\n      <CardContent className=\"space-y-6\">\n        <div className=\"text-center text-sm bg-blue-100 dark:bg-blue-900 p-3 rounded\"><p className=\"font-semibold\">Instructions:</p><p>Press <kbd className=\"px-2 py-1 bg-white dark:bg-gray-800 rounded border\">SPACEBAR</kbd> when you see <strong className=\"text-green-600\">GO</strong></p><p>Do NOT press anything when you see <strong className=\"text-red-600\">NO-GO</strong></p></div>\n        <div className=\"flex flex-col items-center justify-center h-72 relative\">\n          {phase === 'fixation' && <div className=\"text-6xl font-bold text-muted-foreground\">+</div>}\n          {phase === 'stimulus' && <div className={`text-7xl font-bold px-8 py-4 rounded-lg ${trialType === 'go' ? 'bg-green-500 text-white' : 'bg-red-500 text-white'}`}>{trialType === 'go' ? 'GO' : 'NO-GO'}</div>}\n          {phase === 'feedback' && feedback && <div className={`text-xl font-bold ${feedback.includes('âœ“') ? 'text-green-600' : 'text-red-600'}`}>{feedback}</div>}\n        </div>\n        <div className=\"grid grid-cols-3 gap-4 text-center text-sm\"><div><div className=\"text-2xl font-bold text-green-600\">{results.filter(r => r.trialType === 'go' && r.status === 1).length}</div><div className=\"text-xs text-muted-foreground\">Go Correct</div></div><div><div className=\"text-2xl font-bold text-blue-600\">{results.filter(r => r.trialType === 'nogo' && r.status === 1).length}</div><div className=\"text-xs text-muted-foreground\">No-Go Correct</div></div><div><div className=\"text-2xl font-bold text-red-600\">{results.filter(r => r.error === 1).length}</div><div className=\"text-xs text-muted-foreground\">Total Errors</div></div></div>\n      </CardContent>\n    </Card>\n  );\n};"
  },
  {
    "id": "nback",
    "name": "N-Back (2-Back)",
    "fullName": "2-Back Working Memory Task",
    "shortDescription": "Measures working memory capacity and updating",
    "category": "Working Memory",
    "difficulty": "Intermediate",
    "duration": "~1-2 minutes",
    "trials": "30 trials (2 blocks)",
    "measures": ["Working memory", "Updating ability", "Sustained attention", "Executive function"],
    "keywords": ["n-back", "working memory", "memory", "updating", "executive function", "2-back"],
    "requiresCamera": false,
    "codePattern": "Letter sequence tracking, n-back matching, hits/misses/false alarms tracking, block structure",
    "keyFeatures": [
      "2-back memory task",
      "Letter sequence presentation",
      "M key for match responses",
      "Block-based structure",
      "Performance feedback after each block"
    ],
    "code": "import { useState, useEffect } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\n\nexport const NBackTemplate = ({ onComplete }) => {\n  const [currentBlock, setCurrentBlock] = useState(1);\n  const [currentTrial, setCurrentTrial] = useState(0);\n  const [letter, setLetter] = useState('');\n  const [sequence, setSequence] = useState([]);\n  const [phase, setPhase] = useState('ready');\n  const [startTime, setStartTime] = useState(0);\n  const [results, setResults] = useState([]);\n  const [responded, setResponded] = useState(false);\n  const [feedback, setFeedback] = useState('');\n  const [blockStats, setBlockStats] = useState({ hits: 0, misses: 0, falseAlarms: 0, correctRejections: 0 });\n\n  const letters = ['A', 'B', 'C', 'D', 'E', 'H', 'I', 'K', 'L', 'M', 'O', 'P', 'R', 'S', 'T'];\n  const trialsPerBlock = 15;\n  const totalBlocks = 2;\n  const nBack = 2;\n\n  useEffect(() => {\n    const handleKeyPress = (e) => { if (phase === 'letter' && e.key === 'm' && !responded) { setResponded(true); handleResponse(true); } };\n    window.addEventListener('keydown', handleKeyPress);\n    return () => window.removeEventListener('keydown', handleKeyPress);\n  }, [phase, responded, sequence]);\n\n  const startBlock = () => { setCurrentTrial(0); setSequence([]); setBlockStats({ hits: 0, misses: 0, falseAlarms: 0, correctRejections: 0 }); setPhase('letter'); startTrial(); };\n\n  const startTrial = () => {\n    if (currentTrial >= trialsPerBlock) { endBlock(); return; }\n    setResponded(false);\n    setFeedback('');\n    let newLetter;\n    const isMatch = currentTrial >= nBack && Math.random() < 0.3;\n    if (isMatch) { newLetter = sequence[sequence.length - nBack]; } else { do { newLetter = letters[Math.floor(Math.random() * letters.length)]; } while (currentTrial >= nBack && newLetter === sequence[sequence.length - nBack]); }\n    setLetter(newLetter);\n    const newSequence = [...sequence, newLetter];\n    setSequence(newSequence);\n    setPhase('letter');\n    setStartTime(Date.now());\n    setTimeout(() => { setPhase('blank'); setTimeout(() => { if (!responded) { handleResponse(false); } }, 2500); }, 500);\n  };\n\n  const handleResponse = (didRespond) => {\n    const rt = Date.now() - startTime;\n    const isMatchTrial = currentTrial >= nBack && sequence[sequence.length - 1] === sequence[sequence.length - 1 - nBack];\n    let isCorrect, resultType;\n    if (isMatchTrial && didRespond) { isCorrect = true; resultType = 'hit'; setBlockStats(prev => ({ ...prev, hits: prev.hits + 1 })); } else if (isMatchTrial && !didRespond) { isCorrect = false; resultType = 'miss'; setBlockStats(prev => ({ ...prev, misses: prev.misses + 1 })); } else if (!isMatchTrial && didRespond) { isCorrect = false; resultType = 'falseAlarm'; setBlockStats(prev => ({ ...prev, falseAlarms: prev.falseAlarms + 1 })); } else { isCorrect = true; resultType = 'correctRejection'; setBlockStats(prev => ({ ...prev, correctRejections: prev.correctRejections + 1 })); }\n    const result = { block: currentBlock, trial: currentTrial + 1, letter: letter, isMatch: isMatchTrial ? 1 : 0, responded: didRespond ? 1 : 0, correct: isCorrect ? 1 : 0, resultType, rt: didRespond ? rt : 3000 };\n    setResults([...results, result]);\n    if (didRespond) { setFeedback(isCorrect ? 'âœ“' : 'âœ—'); }\n    setTimeout(() => { setCurrentTrial(currentTrial + 1); startTrial(); }, 200);\n  };\n\n  const endBlock = () => { setPhase('blockEnd'); };\n  const nextBlock = () => { if (currentBlock >= totalBlocks) { onComplete?.(results); } else { setCurrentBlock(currentBlock + 1); setPhase('ready'); } };\n\n  if (phase === 'ready') {\n    return (\n      <Card className=\"w-full max-w-2xl mx-auto\"><CardHeader><CardTitle>N-Back Task (2-Back)</CardTitle><CardDescription>Block {currentBlock} of {totalBlocks}</CardDescription></CardHeader><CardContent className=\"space-y-6\"><div className=\"bg-blue-100 dark:bg-blue-900 p-4 rounded space-y-3\"><p className=\"font-semibold text-lg\">Instructions:</p><p>You will see a sequence of letters, one at a time.</p><p>Press <kbd className=\"px-2 py-1 bg-white dark:bg-gray-800 rounded border font-bold\">M</kbd> if the current letter is the SAME as the letter shown <strong>2 positions back</strong>.</p><p>Otherwise, do NOT press anything.</p><div className=\"text-sm text-muted-foreground mt-4\"><p>Example: If you see: H â†’ K â†’ <strong>H</strong></p><p>Press M on the second H because it matches 2 back!</p></div></div><Button onClick={startBlock} size=\"lg\" className=\"w-full\">Start Block {currentBlock}</Button></CardContent></Card>\n    );\n  }\n\n  if (phase === 'blockEnd') {\n    const accuracy = blockStats.hits + blockStats.correctRejections;\n    const total = trialsPerBlock;\n    const percentage = ((accuracy / total) * 100).toFixed(1);\n    return (\n      <Card className=\"w-full max-w-2xl mx-auto\"><CardHeader><CardTitle>Block {currentBlock} Complete!</CardTitle><CardDescription>Your Performance</CardDescription></CardHeader><CardContent className=\"space-y-6\"><div className=\"grid grid-cols-2 gap-4\"><div className=\"bg-green-100 dark:bg-green-900 p-4 rounded text-center\"><div className=\"text-3xl font-bold text-green-600\">{blockStats.hits}</div><div className=\"text-sm\">Hits</div></div><div className=\"bg-blue-100 dark:bg-blue-900 p-4 rounded text-center\"><div className=\"text-3xl font-bold text-blue-600\">{blockStats.correctRejections}</div><div className=\"text-sm\">Correct Rejections</div></div><div className=\"bg-yellow-100 dark:bg-yellow-900 p-4 rounded text-center\"><div className=\"text-3xl font-bold text-yellow-600\">{blockStats.misses}</div><div className=\"text-sm\">Misses</div></div><div className=\"bg-red-100 dark:bg-red-900 p-4 rounded text-center\"><div className=\"text-3xl font-bold text-red-600\">{blockStats.falseAlarms}</div><div className=\"text-sm\">False Alarms</div></div></div><div className=\"text-center p-4 bg-muted rounded\"><div className=\"text-4xl font-bold\">{percentage}%</div><div className=\"text-sm text-muted-foreground\">Accuracy</div></div><Button onClick={nextBlock} size=\"lg\" className=\"w-full\">{currentBlock >= totalBlocks ? 'View Results' : `Continue to Block ${currentBlock + 1}`}</Button></CardContent></Card>\n    );\n  }\n\n  return (\n    <Card className=\"w-full max-w-2xl mx-auto\"><CardHeader><CardTitle>N-Back Task (2-Back)</CardTitle><CardDescription>Block {currentBlock} of {totalBlocks} - Trial {currentTrial + 1} of {trialsPerBlock}</CardDescription></CardHeader><CardContent className=\"space-y-6\"><div className=\"text-center text-sm text-muted-foreground\">Press <kbd className=\"px-2 py-1 bg-muted rounded border\">M</kbd> if the letter matches 2 back</div><div className=\"flex flex-col items-center justify-center h-80 relative\">{phase === 'letter' && <div className=\"text-9xl font-bold\">{letter}</div>}{phase === 'blank' && feedback && <div className={`text-6xl font-bold ${feedback === 'âœ“' ? 'text-green-600' : 'text-red-600'}`}>{feedback}</div>}{phase === 'blank' && !feedback && <div className=\"text-6xl font-bold text-muted-foreground opacity-20\">â€¢</div>}</div><div className=\"grid grid-cols-4 gap-2 text-center text-xs\"><div><div className=\"font-bold text-green-600\">{blockStats.hits}</div><div className=\"text-muted-foreground\">Hits</div></div><div><div className=\"font-bold text-blue-600\">{blockStats.correctRejections}</div><div className=\"text-muted-foreground\">Correct</div></div><div><div className=\"font-bold text-yellow-600\">{blockStats.misses}</div><div className=\"text-muted-foreground\">Misses</div></div><div><div className=\"font-bold text-red-600\">{blockStats.falseAlarms}</div><div className=\"text-muted-foreground\">False Alarms</div></div></div></CardContent></Card>\n  );\n};"
  },
 {
  "id": "hanoi1",
  "name": "Tower of Hanoi",
  "fullName": "Tower of Hanoi Problem-Solving Task",
  "shortDescription": "Evaluates planning, problem-solving, and executive function",
  "detailedDescription": "The Tower of Hanoi is a classic problem-solving task that has been used in psychological research for over a century. Invented by French mathematician Ã‰douard Lucas in 1883, it provides a pure measure of planning ability, working memory, and strategic thinking.\n\n**The Challenge:**\nParticipants must move a stack of discs from one peg to another, following two simple rules:\n1. Move only one disc at a time\n2. Never place a larger disc on top of a smaller disc\n\nWith 3 discs, the optimal solution requires 7 moves (2Â³-1). With 4 discs, 15 moves. The complexity grows exponentially.\n\n**Cognitive Processes Involved:**\n- **Planning**: Thinking ahead multiple moves\n- **Working Memory**: Keeping track of disc positions and goals\n- **Problem Decomposition**: Breaking the problem into subgoals\n- **Hierarchical Thinking**: Understanding nested goal structures\n- **Mental Simulation**: Imagining consequences of actions\n\n**Why It's Powerful:**\nThe Tower of Hanoi is a perfect isomorph of many real-world planning problems. Success requires:\n- Understanding recursive structure\n- Resisting impulsive moves toward the goal\n- Recognizing that sometimes you must move away from the goal to eventually achieve it\n\n**Clinical Applications:**\n- Assessment of executive dysfunction\n- Frontal lobe damage evaluation\n- Tracking cognitive development in children\n- Monitoring cognitive decline in dementia\n- Measuring effects of cognitive training\n\n**Individual Differences:**\n- Age: Performance improves through childhood, peaks in young adulthood\n- Education: Correlates with years of schooling\n- Experience: Practice effects are substantial\n- Strategy: Some use perceptual strategy, others recursive algorithm",
  "duration": "~5 minutes",
  "trials": "1 puzzle (3 discs)",
  "difficulty": "Advanced",
  "category": "Problem Solving",
  "measures": [
    "Planning ability",
    "Problem-solving efficiency",
    "Working memory",
    "Strategic thinking",
    "Number of moves",
    "Solution time"
  ],
  "icon": "Puzzle",
  "color": "from-red-500 to-rose-500",
  "requiresCamera": false,
  "keywords": [
    "tower of hanoi",
    "problem solving",
    "planning",
    "executive function",
    "strategy"
  ],
  "researchAreas": [
    "Cognitive Psychology",
    "Neuropsychology",
    "Developmental Psychology"
  ],
  "publications": [
    "Simon, H. A. (1975). The functional equivalence of problem solving skills",
    "Welsh, M. C., et al. (1991). Towers of Hanoi and London"
  ],
  "code": "import { useState } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\n\nexport const TowerHanoiTemplate = ({ onComplete }) => {\n  // Initialize with 3 discs on left peg (3=largest, 2=medium, 1=smallest)\n  const [pegs, setPegs] = useState([[3, 2, 1], [], []]);\n  const [selectedPeg, setSelectedPeg] = useState(null);\n  const [moves, setMoves] = useState(0);\n  const [errors, setErrors] = useState({ biggerOnSmaller: 0, invalidMove: 0 });\n  const [startTime] = useState(Date.now());\n  const [results, setResults] = useState([]);\n  const [isComplete, setIsComplete] = useState(false);\n\n  const handlePegClick = (pegIndex) => {\n    if (isComplete) return;\n\n    if (selectedPeg === null) {\n      // Select a disc from a peg\n      if (pegs[pegIndex].length > 0) {\n        setSelectedPeg(pegIndex);\n      } else {\n        // Trying to select from empty peg - invalid move\n        setErrors(prev => ({ ...prev, invalidMove: prev.invalidMove + 1 }));\n      }\n    } else {\n      // Try to move disc to target peg\n      if (selectedPeg === pegIndex) {\n        // Clicked same peg - deselect\n        setSelectedPeg(null);\n        return;\n      }\n\n      const sourcePeg = pegs[selectedPeg];\n      const targetPeg = pegs[pegIndex];\n      const disc = sourcePeg[sourcePeg.length - 1]; // Top disc from source\n      const targetTopDisc = targetPeg[targetPeg.length - 1]; // Top disc on target\n\n      // Check if move is valid: bigger disc cannot go on smaller disc\n      if (targetTopDisc !== undefined && disc > targetTopDisc) {\n        // Invalid: trying to place bigger on smaller\n        setErrors(prev => ({ ...prev, biggerOnSmaller: prev.biggerOnSmaller + 1 }));\n        setSelectedPeg(null);\n        return;\n      }\n\n      // Valid move - execute it\n      const newPegs = pegs.map((peg, i) => {\n        if (i === selectedPeg) return peg.slice(0, -1); // Remove top disc from source\n        if (i === pegIndex) return [...peg, disc]; // Add disc to target\n        return peg;\n      });\n\n      setPegs(newPegs);\n      const newMoves = moves + 1;\n      setMoves(newMoves);\n      setSelectedPeg(null);\n\n      // Record this step\n      const result = {\n        timeMs: Date.now() - startTime,\n        stepNumber: newMoves,\n        errorsBigOnSmall: errors.biggerOnSmaller,\n        errorsInvalid: errors.invalidMove,\n        pegStates: newPegs.map(p => [...p]) // Save state after this move\n      };\n\n      const newResults = [...results, result];\n      setResults(newResults);\n\n      // Check if puzzle is solved (all discs on rightmost peg)\n      if (newPegs[2].length === 3 && newPegs[2][0] === 3 && newPegs[2][1] === 2 && newPegs[2][2] === 1) {\n        setIsComplete(true);\n        // Wait a moment to show completion before calling onComplete\n        setTimeout(() => {\n          onComplete?.({\n            totalMoves: newMoves,\n            totalTime: Date.now() - startTime,\n            errorsBigOnSmaller: errors.biggerOnSmaller,\n            errorsInvalid: errors.invalidMove,\n            minimumMoves: 7,\n            efficiency: (7 / newMoves) * 100, // Percentage of optimal\n            allSteps: newResults\n          });\n        }, 500);\n      }\n    }\n  };\n\n  const resetPuzzle = () => {\n    setPegs([[3, 2, 1], [], []]);\n    setSelectedPeg(null);\n    setMoves(0);\n    setErrors({ biggerOnSmaller: 0, invalidMove: 0 });\n    setResults([]);\n    setIsComplete(false);\n  };\n\n  const getDiscColor = (size) => {\n    const colors = {\n      1: 'bg-blue-500',    // Smallest - Blue\n      2: 'bg-green-500',   // Medium - Green\n      3: 'bg-red-500'      // Largest - Red\n    };\n    return colors[size];\n  };\n\n  const getDiscWidth = (size) => {\n    const widths = {\n      1: 60,   // Smallest\n      2: 90,   // Medium\n      3: 120   // Largest\n    };\n    return widths[size];\n  };\n\n  return (\n    <Card className=\"w-full max-w-4xl mx-auto\">\n      <CardHeader>\n        <CardTitle className=\"flex items-center justify-between\">\n          <span>Tower of Hanoi</span>\n          {isComplete && (\n            <span className=\"text-green-600 dark:text-green-400 text-lg\">\n              âœ“ Completed!\n            </span>\n          )}\n        </CardTitle>\n        <CardDescription className=\"space-y-1\">\n          <div className=\"flex gap-6\">\n            <span>Moves: {moves}</span>\n            <span>Time: {Math.floor((Date.now() - startTime) / 1000)}s</span>\n            <span className=\"text-red-600 dark:text-red-400\">\n              Errors: {errors.biggerOnSmaller + errors.invalidMove}\n              {errors.biggerOnSmaller > 0 && ` (${errors.biggerOnSmaller} big-on-small)`}\n              {errors.invalidMove > 0 && ` (${errors.invalidMove} invalid)`}\n            </span>\n          </div>\n        </CardDescription>\n      </CardHeader>\n      <CardContent className=\"space-y-6\">\n        {/* Instructions */}\n        <div className=\"bg-muted/50 p-4 rounded-lg space-y-2\">\n          <h3 className=\"font-semibold\">Instructions:</h3>\n          <ul className=\"text-sm space-y-1 list-disc list-inside\">\n            <li>Move all discs from the <strong>left peg</strong> to the <strong>right peg</strong></li>\n            <li>Only one disc can be moved at a time</li>\n            <li>A larger disc <strong>cannot</strong> be placed on a smaller disc</li>\n            <li>Minimum moves to solve: <strong>7 moves</strong></li>\n          </ul>\n        </div>\n\n        {/* Tower of Hanoi Pegs */}\n        <div className=\"flex justify-around items-end py-8 px-4\" style={{ height: '300px' }}>\n          {pegs.map((peg, pegIndex) => (\n            <div\n              key={pegIndex}\n              className={`relative flex flex-col items-center cursor-pointer transition-all ${\n                selectedPeg === pegIndex \n                  ? 'scale-105' \n                  : 'hover:scale-102'\n              }`}\n              onClick={() => handlePegClick(pegIndex)}\n            >\n              {/* Peg Label */}\n              <div className=\"absolute -top-8 text-sm font-semibold text-muted-foreground\">\n                {pegIndex === 0 && 'Start'}\n                {pegIndex === 1 && 'Aux'}\n                {pegIndex === 2 && 'Goal'}\n              </div>\n\n              {/* Discs Container */}\n              <div className=\"flex flex-col-reverse items-center gap-1 relative\" style={{ minHeight: '200px' }}>\n                {/* Vertical Peg */}\n                <div \n                  className={`absolute bottom-0 w-3 bg-gray-400 dark:bg-gray-600 rounded-t-full transition-all ${\n                    selectedPeg === pegIndex ? 'ring-4 ring-blue-500' : ''\n                  }`}\n                  style={{ height: '200px', zIndex: 0 }}\n                ></div>\n\n                {/* Discs */}\n                <div className=\"flex flex-col-reverse items-center gap-1 relative\" style={{ zIndex: 1, paddingBottom: '4px' }}>\n                  {peg.map((disc, discIndex) => (\n                    <div\n                      key={discIndex}\n                      className={`${getDiscColor(disc)} h-10 rounded shadow-lg transition-all ${\n                        selectedPeg === pegIndex && discIndex === peg.length - 1\n                          ? 'ring-4 ring-yellow-400 scale-110'\n                          : ''\n                      }`}\n                      style={{ \n                        width: `${getDiscWidth(disc)}px`,\n                        transition: 'all 0.2s ease'\n                      }}\n                    >\n                      <div className=\"h-full flex items-center justify-center text-white font-bold text-sm\">\n                        {disc}\n                      </div>\n                    </div>\n                  ))}\n                </div>\n              </div>\n\n              {/* Base */}\n              <div className=\"w-40 h-3 bg-gray-600 dark:bg-gray-700 rounded mt-1\"></div>\n            </div>\n          ))}\n        </div>\n\n        {/* Action Buttons */}\n        <div className=\"flex justify-center gap-4\">\n          <Button \n            variant=\"outline\" \n            onClick={resetPuzzle}\n            disabled={moves === 0 && !isComplete}\n          >\n            Reset Puzzle\n          </Button>\n          {isComplete && (\n            <Button \n              onClick={() => onComplete?.({\n                totalMoves: moves,\n                totalTime: Date.now() - startTime,\n                errorsBigOnSmaller: errors.biggerOnSmaller,\n                errorsInvalid: errors.invalidMove,\n                minimumMoves: 7,\n                efficiency: (7 / moves) * 100,\n                allSteps: results\n              })}\n            >\n              Continue\n            </Button>\n          )}\n        </div>\n\n        {/* Performance Stats */}\n        {moves > 0 && (\n          <div className=\"bg-muted/30 p-4 rounded-lg\">\n            <h3 className=\"font-semibold mb-2\">Performance:</h3>\n            <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 text-sm\">\n              <div>\n                <div className=\"text-muted-foreground\">Current Moves</div>\n                <div className=\"text-lg font-bold\">{moves}</div>\n              </div>\n              <div>\n                <div className=\"text-muted-foreground\">Optimal Moves</div>\n                <div className=\"text-lg font-bold\">7</div>\n              </div>\n              <div>\n                <div className=\"text-muted-foreground\">Efficiency</div>\n                <div className=\"text-lg font-bold\">\n                  {moves > 0 ? Math.round((7 / moves) * 100) : 0}%\n                </div>\n              </div>\n              <div>\n                <div className=\"text-muted-foreground\">Total Errors</div>\n                <div className=\"text-lg font-bold text-red-600 dark:text-red-400\">\n                  {errors.biggerOnSmaller + errors.invalidMove}\n                </div>\n              </div>\n            </div>\n          </div>\n        )}\n      </CardContent>\n    </Card>\n  );\n};"
  },
  {
    "id": "abba",
    "name": "ABBA Task",
    "fullName": "Action-Based Backward Activation",
    "shortDescription": "Examines action planning and response compatibility effects",
    "detailedDescription": "The ABBA (Action-Based Backward Activation) Task is an innovative paradigm that explores the reversed-compatibility effect, revealing fascinating insights into how we plan and execute actions. This task demonstrates that action planning can create unique cognitive states that affect subsequent responses.\n\n**The Paradigm:**\nParticipants prepare one action (e.g., moving left) but then execute a different action (e.g., responding to a stimulus). The critical finding is that response compatibility effects reverse during action preparation - stimuli that are incompatible with the prepared action are processed faster than compatible stimuli.\n\n**Why This Matters:**\nThe reversed-compatibility effect challenges traditional views of stimulus-response compatibility. It shows that actively planning an action creates a specific cognitive context that affects how we process information, revealing deep connections between action planning and perception.\n\n**Theoretical Implications:**\n- Action planning involves active suppression of competing responses\n- Motor preparation influences perceptual processing\n- Response selection is dynamic and context-dependent\n- Evidence for embodied cognition theories\n\n**Research Applications:**\n- Understanding action control mechanisms\n- Motor planning in neurological disorders\n- Response inhibition and flexibility\n- Cognitive-motor interactions\n- Development of motor control\n\n**What We Learn:**\n- How action plans influence cognition\n- Mechanisms of response inhibition\n- Flexibility in stimulus-response mapping\n- Individual differences in motor-cognitive coupling",
    "duration": "~2 minutes",
    "trials": "40 trials",
    "difficulty": "Advanced",
    "category": "Motor Control",
    "measures": [
      "Action planning",
      "Response compatibility",
      "Motor control",
      "Cognitive flexibility",
      "Response inhibition",
      "Reversed compatibility effect"
    ],
    "icon": "Layers",
    "color": "from-green-500 to-emerald-500",
    "requiresCamera": false,
    "keywords": [
      "ABBA",
      "action planning",
      "motor control",
      "compatibility",
      "response selection"
    ],
    "researchAreas": [
      "Cognitive Psychology",
      "Motor Control",
      "Action Research"
    ],
    "publications": [
      "Proctor, R. W., & Vu, K. P. L. (2006). Stimulus-response compatibility principles",
      "Hommel, B. (2011). The Simon effect as tool and heuristic"
    ],
    "code": "import { useState, useEffect } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\n\nexport const ABBATemplate = ({ onComplete }) => {\n  const [currentTrial, setCurrentTrial] = useState(0);\n  const [phase, setPhase] = useState('stimulusA');\n  const [stimulusA, setStimulusA] = useState({ side: 'left', count: 1 });\n  const [stimulusB, setStimulusB] = useState({ side: 'left', count: 1 });\n  const [startTime, setStartTime] = useState(0);\n  const [results, setResults] = useState([]);\n  const [responseAPresses, setResponseAPresses] = useState([]);\n\n  useEffect(() => { startTrial(); }, [currentTrial]);\n\n  const startTrial = () => {\n    if (currentTrial >= 40) { onComplete?.(results); return; }\n    const sideA = Math.random() < 0.5 ? 'left' : 'right';\n    const countA = Math.random() < 0.5 ? 1 : 2;\n    const sideB = Math.random() < 0.5 ? 'left' : 'right';\n    const countB = Math.random() < 0.5 ? 1 : 2;\n    setStimulusA({ side: sideA, count: countA });\n    setStimulusB({ side: sideB, count: countB });\n    setPhase('stimulusA');\n    setResponseAPresses([]);\n    setTimeout(() => { setPhase('delay'); setTimeout(() => { setPhase('stimulusB'); setStartTime(Date.now()); }, 2000); }, 2000);\n  };\n\n  const handleResponseB = (side) => {\n    const rt = Date.now() - startTime;\n    setPhase('responseA');\n    setStartTime(Date.now());\n    window.responseBData = { side, rt };\n  };\n\n  const handleResponseA = (side) => {\n    const rt = Date.now() - startTime;\n    const newPresses = [...responseAPresses, { side, rt }];\n    setResponseAPresses(newPresses);\n    const expectedPresses = stimulusA.count;\n    if (newPresses.length >= expectedPresses) {\n      const result = { stimulusA, stimulusB, responseB: window.responseBData, responseA: newPresses, compatible: stimulusA.side === stimulusB.side ? 0 : 1 };\n      setResults([...results, result]);\n      setCurrentTrial(currentTrial + 1);\n    }\n  };\n\n  return (\n    <Card className=\"w-full max-w-2xl mx-auto\">\n      <CardHeader><CardTitle>ABBA Task</CardTitle><CardDescription>Trial {currentTrial + 1} of 40</CardDescription></CardHeader>\n      <CardContent className=\"space-y-6\">\n        <div className=\"text-center text-sm text-muted-foreground\">Plan response with S/K keys, respond immediately with A/L keys</div>\n        <div className=\"h-64 flex items-center justify-center\">\n          {phase === 'stimulusA' && <div className=\"text-4xl\">Plan: {stimulusA.side === 'left' ? 'S' : 'K'}{stimulusA.count === 2 && ` + ${stimulusA.side === 'left' ? 'S' : 'K'}`}</div>}\n          {phase === 'delay' && <div className=\"text-2xl text-muted-foreground\">Wait...</div>}\n          {phase === 'stimulusB' && <div className=\"space-y-4\"><div className=\"text-4xl\">Respond NOW!</div><div className=\"flex gap-4 justify-center\"><Button size=\"lg\" onClick={() => handleResponseB('left')}>A (Left)</Button><Button size=\"lg\" onClick={() => handleResponseB('right')}>L (Right)</Button></div></div>}\n          {phase === 'responseA' && <div className=\"space-y-4\"><div className=\"text-4xl\">Execute planned response!</div><div className=\"flex gap-4 justify-center\"><Button size=\"lg\" onClick={() => handleResponseA('left')}>S (Left)</Button><Button size=\"lg\" onClick={() => handleResponseA('right')}>K (Right)</Button></div><div className=\"text-sm\">{responseAPresses.length} of {stimulusA.count} presses</div></div>}\n        </div>\n      </CardContent>\n    </Card>\n  );\n};"
  },
  {
    "id": "visualsearch",
    "name": "Visual Search",
    "fullName": "Conjunction Visual Search Task",
    "shortDescription": "Measures visual attention and search efficiency",
    "detailedDescription": "The Visual Search Task is a fundamental paradigm for understanding how we find objects in cluttered visual environments. Based on Feature Integration Theory (Treisman & Gelade, 1980), this task reveals the mechanisms of visual attention and the distinction between parallel and serial processing.\n\n**Task Design:**\nParticipants search for a target among distractors. In this conjunction search version, the target is defined by a combination of features (e.g., an orange upright T) among distractors sharing one feature (orange rotated Ts and blue upright Ts). This requires binding features together, demanding focused attention.\n\n**Search Types:**\n- **Feature Search**: Target differs by single feature (parallel, fast, 'pop-out')\n- **Conjunction Search**: Target requires combining features (serial, slow, effortful)\n\n**Set Size Effects:**\nIn conjunction searches, reaction time increases linearly with the number of distractors (set size), suggesting serial item-by-item examination. The slope of this function (RT increase per item) reveals search efficiency.\n\n**Theoretical Importance:**\nVisual search tasks test fundamental theories about:\n- Pre-attentive vs attentive processing\n- Feature binding and integration\n- Capacity limits of attention\n- Top-down vs bottom-up control\n- Visual working memory\n\n**Applications:**\n- Understanding visual expertise (radiology, security screening)\n- Aging effects on visual attention\n- Developmental changes in attention\n- Individual differences in attention capacity\n- Neuropsychological assessment",
    "duration": "~1-2 minutes",
    "trials": "20 trials (3 training)",
    "difficulty": "Intermediate",
    "category": "Attention",
    "measures": [
      "Visual attention",
      "Search slopes",
      "Feature integration",
      "Processing efficiency",
      "Set size effects",
      "Search accuracy"
    ],
    "icon": "Search",
    "color": "from-indigo-500 to-blue-500",
    "requiresCamera": false,
    "keywords": [
      "visual search",
      "attention",
      "perception",
      "feature integration",
      "conjunction"
    ],
    "researchAreas": [
      "Cognitive Psychology",
      "Vision Science",
      "Human Factors"
    ],
    "publications": [
      "Treisman, A. M., & Gelade, G. (1980). A feature-integration theory",
      "Wolfe, J. M. (1994). Guided Search 2.0"
    ],
    "code": "import { useState, useEffect } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\n\nexport const VisualSearchTemplate = ({ onComplete }) => {\n  const [currentTrial, setCurrentTrial] = useState(0);\n  const [isTraining, setIsTraining] = useState(true);\n  const [items, setItems] = useState([]);\n  const [targetPresent, setTargetPresent] = useState(true);\n  const [setSize, setSetSize] = useState(4);\n  const [startTime, setStartTime] = useState(0);\n  const [results, setResults] = useState([]);\n\n  const setSizes = [4, 8, 12];\n  const targetColor = '#FF6B35';\n  const distractorColors = ['#FF6B35', '#4ECDC4'];\n\n  useEffect(() => { generateTrial(); }, [currentTrial]);\n\n  const generateTrial = () => {\n    const totalTrials = isTraining ? 3 : 20;\n    if (currentTrial >= totalTrials) { if (isTraining) { setIsTraining(false); setCurrentTrial(0); return; } else { onComplete?.(results); return; } }\n    const newSetSize = setSizes[Math.floor(Math.random() * setSizes.length)];\n    const hasTarget = Math.random() < 0.5;\n    setSetSize(newSetSize);\n    setTargetPresent(hasTarget);\n    const newItems = [];\n    const gridSize = 400;\n    const positions = [];\n    for (let i = 0; i < newSetSize; i++) {\n      let x, y, overlapping;\n      do {\n        overlapping = false;\n        x = Math.random() * (gridSize - 60) + 30;\n        y = Math.random() * (gridSize - 60) + 30;\n        for (const pos of positions) { if (Math.hypot(x - pos.x, y - pos.y) < 50) { overlapping = true; break; } }\n      } while (overlapping);\n      positions.push({ x, y });\n      const isTarget = hasTarget && i === 0;\n      const color = isTarget ? targetColor : distractorColors[Math.floor(Math.random() * distractorColors.length)];\n      const rotation = isTarget ? 0 : Math.random() < 0.5 ? 90 : 180;\n      newItems.push({ x, y, color, rotation, isTarget });\n    }\n    setItems(newItems);\n    setStartTime(Date.now());\n  };\n\n  const handleResponse = (response) => {\n    const rt = Date.now() - startTime;\n    const correct = response === targetPresent;\n    const result = { setSize, targetPresent: targetPresent ? 1 : 0, response: response ? 1 : 0, correct: correct ? 1 : 0, rt, isTraining: isTraining ? 1 : 0 };\n    setResults([...results, result]);\n    setCurrentTrial(currentTrial + 1);\n  };\n\n  return (\n    <Card className=\"w-full max-w-3xl mx-auto\">\n      <CardHeader><CardTitle>Visual Search Task</CardTitle><CardDescription>{isTraining ? `Training Trial ${currentTrial + 1} of 3` : `Trial ${currentTrial + 1} of 20`}</CardDescription></CardHeader>\n      <CardContent className=\"space-y-6\">\n        <div className=\"bg-blue-100 dark:bg-blue-900 p-3 rounded text-sm text-center\"><p className=\"font-semibold\">Find the orange upright T</p><p className=\"text-xs mt-1\">Press 'Present' if you see it, 'Absent' if you don't</p></div>\n        <div className=\"relative bg-gray-100 dark:bg-gray-800 rounded\" style={{ width: '400px', height: '400px', margin: '0 auto' }}>\n          {items.map((item, idx) => (\n            <div key={idx} style={{ position: 'absolute', left: `${item.x}px`, top: `${item.y}px`, transform: `rotate(${item.rotation}deg)`, color: item.color, fontSize: '32px', fontWeight: 'bold', fontFamily: 'monospace' }}>T</div>\n          ))}\n        </div>\n        <div className=\"flex gap-4 justify-center\"><Button onClick={() => handleResponse(true)} size=\"lg\" className=\"w-32\">Present</Button><Button onClick={() => handleResponse(false)} size=\"lg\" variant=\"outline\" className=\"w-32\">Absent</Button></div>\n        <div className=\"text-center text-xs text-muted-foreground\">{isTraining ? 'ðŸŽ“ Training Mode' : `Set Size: ${setSize} items`}</div>\n      </CardContent>\n    </Card>\n  );\n};"
  },
   {
    "id": "digitspan",
    "name": "Digit Span",
    "fullName": "Digit Span Memory Test",
    "shortDescription": "Measures short-term memory capacity",
    "detailedDescription": "The Digit Span Test is one of the oldest and most well-established measures of short-term memory capacity, dating back to the early days of intelligence testing. It provides a simple yet reliable assessment of how much information we can hold in immediate memory.\n\n**Test Procedure:**\nParticipants are presented with sequences of digits (e.g., 3-7-5-2) and must immediately recall them in the correct order. The sequence length starts small (typically 3-4 digits) and increases progressively. Testing continues until the participant fails to correctly recall two consecutive sequences of the same length.\n\n**The Magic Number 7:**\nGeorge Miller's famous 1956 paper \"The Magical Number Seven, Plus or Minus Two\" established that human short-term memory capacity averages around 7 items (ranging from 5 to 9). The Digit Span Test directly measures this fundamental cognitive limit.\n\n**Variants:**\n- **Forward Span**: Recall digits in presented order (basic short-term memory)\n- **Backward Span**: Recall digits in reverse order (working memory and manipulation)\n\n**Clinical Significance:**\nDigit Span is a core subtest in many intelligence scales (WAIS, WISC) and neuropsychological batteries. It's sensitive to:\n- Attention and concentration problems\n- Anxiety effects on performance\n- Memory disorders and dementia\n- Learning disabilities\n- Effects of aging on cognitive capacity\n\n**What Influences Performance:**\n- Age (peaks in early adulthood)\n- Education level\n- Test anxiety\n- Language proficiency\n- Cognitive load and distraction",
    "duration": "~1-2 minutes",
    "trials": "Adaptive (until 2 errors)",
    "difficulty": "Beginner",
    "category": "Memory",
    "measures": [
      "Short-term memory",
      "Memory span",
      "Recall accuracy",
      "Sequential processing",
      "Attention capacity",
      "Auditory processing"
    ],
    "icon": "Hash",
    "color": "from-emerald-500 to-green-500",
    "requiresCamera": false,
    "keywords": [
      "digit span",
      "memory",
      "short-term memory",
      "recall",
      "memory capacity"
    ],
    "researchAreas": [
      "Cognitive Psychology",
      "Clinical Neuropsychology",
      "Intelligence Testing"
    ],
    "publications": [
      "Miller, G. A. (1956). The magical number seven, plus or minus two",
      "Wechsler, D. (2008). Wechsler Adult Intelligence Scale"
    ],
    
  "code": "import { useState } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\n\nexport const DigitSpanTemplate = ({ onComplete }) => {\n  const [phase, setPhase] = useState('instructions');\n  const [currentSequence, setCurrentSequence] = useState([]);\n  const [userSequence, setUserSequence] = useState([]);\n  const [spanLength, setSpanLength] = useState(3);\n  const [correctAtLength, setCorrectAtLength] = useState(0);\n  const [consecutiveErrors, setConsecutiveErrors] = useState(0);\n  const [maxSpan, setMaxSpan] = useState(0);\n  const [results, setResults] = useState([]);\n  const [showingIndex, setShowingIndex] = useState(0);\n  const digits = [0,1,2,3,4,5,6,7,8,9];\n\n  const startTest = () => { setPhase('showing'); generateSequence(); };\n\n  const generateSequence = () => {\n    const sequence = [];\n    const availableDigits = [...digits];\n    for (let i = 0; i < spanLength; i++) {\n      const randomIndex = Math.floor(Math.random() * availableDigits.length);\n      sequence.push(availableDigits[randomIndex]);\n      availableDigits.splice(randomIndex, 1);\n    }\n    setCurrentSequence(sequence);\n    setUserSequence([]);\n    setShowingIndex(0);\n    showSequence(sequence);\n  };\n\n  const showSequence = (sequence) => {\n    let index = 0;\n    const interval = setInterval(() => {\n      setShowingIndex(index);\n      index++;\n      if (index > sequence.length) {\n        clearInterval(interval);\n        setTimeout(() => {\n          setPhase('recall');\n          setShowingIndex(-1);\n        }, 500);\n      }\n    }, 1000);\n  };\n\n  const handleDigitClick = (digit) => {\n    if (phase !== 'recall') return;\n    const newUserSequence = [...userSequence, digit];\n    setUserSequence(newUserSequence);\n    if (newUserSequence.length === currentSequence.length) {\n      checkAnswer(newUserSequence);\n    }\n  };\n\n  const checkAnswer = (userSeq) => {\n    const correct = JSON.stringify(userSeq) === JSON.stringify(currentSequence);\n    const result = { spanLength, sequence: currentSequence, userResponse: userSeq, correct: correct ? 1 : 0, timestamp: Date.now() };\n    setResults([...results, result]);\n\n    if (correct) {\n      setMaxSpan(Math.max(maxSpan, spanLength));\n      const newCorrectAtLength = correctAtLength + 1;\n      setCorrectAtLength(newCorrectAtLength);\n      setConsecutiveErrors(0);\n      if (newCorrectAtLength >= 2) {\n        if (spanLength >= 9) { endTest(); }\n        else {\n          setSpanLength(spanLength + 1);\n          setCorrectAtLength(0);\n          setTimeout(() => { setPhase('showing'); generateSequence(); }, 1500);\n        }\n      } else {\n        setTimeout(() => { setPhase('showing'); generateSequence(); }, 1500);\n      }\n    } else {\n      const newErrors = consecutiveErrors + 1;\n      setConsecutiveErrors(newErrors);\n      setCorrectAtLength(0);\n      if (newErrors >= 2) { endTest(); }\n      else { setTimeout(() => { setPhase('showing'); generateSequence(); }, 1500); }\n    }\n\n    setPhase('result');\n    setTimeout(() => { if (phase === 'result') setPhase('showing'); }, 1000);\n  };\n\n  const endTest = () => {\n    const finalResult = { maxDigitSpan: maxSpan, totalTrials: results.length + 1, allResults: results };\n    onComplete?.(finalResult);\n  };\n\n  const clearUserSequence = () => { setUserSequence([]); };\n\n  if (phase === 'instructions') {\n    return (\n      <Card className=\"w-full max-w-2xl mx-auto\">\n        <CardHeader>\n          <CardTitle>Digit Span Task</CardTitle>\n          <CardDescription>Test your short-term memory capacity</CardDescription>\n        </CardHeader>\n        <CardContent className=\"space-y-6\">\n          <div className=\"bg-blue-100 dark:bg-blue-900 p-4 rounded space-y-3\">\n            <p className=\"font-semibold text-lg\">Instructions:</p>\n            <ul className=\"list-disc list-inside space-y-2\">\n              <li>You will see a sequence of digits, one at a time</li>\n              <li>Remember the digits in order</li>\n              <li>After the sequence, click the digits in the same order</li>\n              <li>The sequence gets longer as you progress</li>\n              <li>The test ends after 2 consecutive errors or reaching 9 digits</li>\n            </ul>\n          </div>\n          <div className=\"bg-yellow-100 dark:bg-yellow-900 p-3 rounded text-sm\">\n            <p className=\"font-semibold\">ðŸ’¡ Tip:</p>\n            <p>Try to visualize or \\\"chunk\\\" the digits together. Most people can remember 7Â±2 digits!</p>\n          </div>\n          <Button onClick={startTest} size=\"lg\" className=\"w-full\">Start Test</Button>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  if (phase === 'showing') {\n    return (\n      <Card className=\"w-full max-w-2xl mx-auto\">\n        <CardHeader>\n          <CardTitle>Digit Span Task</CardTitle>\n          <CardDescription>Sequence Length: {spanLength} - Remember the digits!</CardDescription>\n        </CardHeader>\n        <CardContent className=\"space-y-6\">\n          <div className=\"text-center text-sm text-muted-foreground\">Watch carefully and remember the order...</div>\n          <div className=\"flex items-center justify-center h-80\">\n            {showingIndex < currentSequence.length && (<div className=\"text-9xl font-bold animate-pulse\">{currentSequence[showingIndex]}</div>)}\n          </div>\n          <div className=\"flex justify-center gap-2\">\n            {currentSequence.map((_, idx) => (<div key={idx} className={`w-3 h-3 rounded-full ${idx <= showingIndex ? 'bg-blue-500' : 'bg-gray-300'}`} />))}\n          </div>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  if (phase === 'recall') {\n    return (\n      <Card className=\"w-full max-w-2xl mx-auto\">\n        <CardHeader>\n          <CardTitle>Digit Span Task</CardTitle>\n          <CardDescription>Click the digits in the correct order ({userSequence.length}/{currentSequence.length})</CardDescription>\n        </CardHeader>\n        <CardContent className=\"space-y-6\">\n          <div className=\"bg-muted p-4 rounded min-h-20 flex items-center justify-center gap-2\">\n            {userSequence.length === 0 ? (<span className=\"text-muted-foreground\">Click digits below...</span>) : (userSequence.map((digit, idx) => (<span key={idx} className=\"text-4xl font-bold\">{digit}</span>)))}\n          </div>\n          <div className=\"grid grid-cols-5 gap-3\">\n            {digits.map((digit) => (<Button key={digit} onClick={() => handleDigitClick(digit)} size=\"lg\" variant=\"outline\" className=\"text-2xl h-16 font-bold\">{digit}</Button>))}\n          </div>\n          <Button onClick={clearUserSequence} variant=\"destructive\" className=\"w-full\" disabled={userSequence.length === 0}>Clear</Button>\n          <div className=\"text-xs text-center text-muted-foreground\">Correct at this length: {correctAtLength}/2 needed to advance</div>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  if (phase === 'result') {\n    const lastResult = results[results.length - 1];\n    const correct = lastResult?.correct === 1;\n    return (\n      <Card className=\"w-full max-w-2xl mx-auto\">\n        <CardHeader>\n          <CardTitle>Digit Span Task</CardTitle>\n          <CardDescription>Trial Result</CardDescription>\n        </CardHeader>\n        <CardContent className=\"space-y-6\">\n          <div className={`text-center p-8 rounded ${correct ? 'bg-green-100 dark:bg-green-900' : 'bg-red-100 dark:bg-red-900'}`}>\n            <div className={`text-6xl font-bold ${correct ? 'text-green-600' : 'text-red-600'}`}>{correct ? 'âœ“ Correct!' : 'âœ— Incorrect'}</div>\n          </div>\n          <div className=\"grid grid-cols-2 gap-4\">\n            <div className=\"bg-muted p-4 rounded text-center\">\n              <div className=\"text-sm text-muted-foreground\">Correct Sequence</div>\n              <div className=\"text-2xl font-bold mt-2\">{lastResult?.sequence.join(' ')}</div>\n            </div>\n            <div className=\"bg-muted p-4 rounded text-center\">\n              <div className=\"text-sm text-muted-foreground\">Your Response</div>\n              <div className=\"text-2xl font-bold mt-2\">{lastResult?.userResponse.join(' ')}</div>\n            </div>\n          </div>\n          <div className=\"text-center\">\n            <div className=\"text-3xl font-bold\">{maxSpan}</div>\n            <div className=\"text-sm text-muted-foreground\">Current Best Span</div>\n          </div>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  return null;\n};"
  },
  {
    "id": "simon",
    "name": "Simon Task",
    "fullName": "Simon Stimulus-Response Compatibility Task",
    "shortDescription": "Measures stimulus-response compatibility and spatial attention",
    "detailedDescription": "The Simon Task, introduced by J. Richard Simon and colleagues in 1967, demonstrates a fascinating phenomenon: even when spatial location is completely irrelevant to the task, it still affects our responses. This reveals fundamental aspects of how our brains automatically process spatial information.\n\n**The Paradigm:**\nParticipants see stimuli (e.g., words or colors) appear on the left or right side of the screen and must respond based on a non-spatial feature (e.g., the meaning or color). For instance, respond with the left key to the word \"LEFT\" and the right key to \"RIGHT,\" regardless of where the word appears.\n\n**The Simon Effect:**\nEven though location is irrelevant, responses are faster when the stimulus location matches the response location (compatible trials: word \"LEFT\" on left side) compared to when they mismatch (incompatible trials: word \"LEFT\" on right side). This interference effect reveals automatic spatial processing.\n\n**Theoretical Importance:**\n- Demonstrates automatic activation of spatial codes\n- Reveals parallel processing of relevant and irrelevant information\n- Shows the cost of inhibiting automatically activated responses\n- Illuminates stimulus-response translation processes\n\n**Research Applications:**\n- Aging studies (Simon effect increases with age)\n- Clinical assessment (enhanced effect in ADHD, Parkinson's)\n- Action control and response selection research\n- Individual differences in cognitive flexibility\n- Cross-modal attention and integration studies",
    "duration": "~1-2 minutes",
    "trials": "24 trials (5 training)",
    "difficulty": "Beginner",
    "category": "Response Selection",
    "measures": [
      "S-R compatibility",
      "Spatial interference",
      "Automatic processing",
      "Simon effect",
      "Response conflict",
      "Inhibitory control"
    ],
    "icon": "Move",
    "color": "from-teal-500 to-cyan-500",
    "requiresCamera": false,
    "keywords": [
      "simon",
      "compatibility",
      "spatial",
      "interference",
      "automatic processing"
    ],
    "researchAreas": [
      "Cognitive Psychology",
      "Neuropsychology",
      "Human Factors"
    ],
    "publications": [
      "Simon, J. R., & Rudell, A. P. (1967). Auditory S-R compatibility",
      "Lu, C. H., & Proctor, R. W. (1995). The influence of irrelevant location information"
    ],
    "code":"import { useState, useEffect } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\n\nexport const SimonTemplate = ({ onComplete }) => {\n  const [currentTrial, setCurrentTrial] = useState(0);\n  const [word, setWord] = useState('');\n  const [position, setPosition] = useState('left');\n  const [phase, setPhase] = useState('fixation');\n  const [startTime, setStartTime] = useState(0);\n  const [results, setResults] = useState([]);\n  const [isTraining, setIsTraining] = useState(true);\n  const [feedback, setFeedback] = useState('');\n\n  const words = ['LEFT', 'RIGHT'];\n\n  useEffect(() => { startTrial(); }, [currentTrial]);\n\n  useEffect(() => {\n    const handleKeyPress = (e) => {\n      if (phase === 'stimulus' && (e.key === 'a' || e.key === 'l')) {\n        handleResponse(e.key === 'a' ? 'left' : 'right');\n      }\n    };\n    window.addEventListener('keydown', handleKeyPress);\n    return () => window.removeEventListener('keydown', handleKeyPress);\n  }, [phase, startTime]);\n\n  const startTrial = () => {\n    const totalTrials = isTraining ? 5 : 24;\n    if (currentTrial >= totalTrials) {\n      if (isTraining) { setIsTraining(false); setCurrentTrial(0); return; } else { onComplete?.(results); return; }\n    }\n\n    setPhase('fixation');\n    setFeedback('');\n\n    const wordChoice = words[Math.floor(Math.random() * words.length)];\n    const posChoice = Math.random() < 0.5 ? 'left' : 'right';\n\n    setWord(wordChoice);\n    setPosition(posChoice);\n\n    setTimeout(() => {\n      setPhase('stimulus');\n      setStartTime(Date.now());\n      setTimeout(() => {\n        if (phase === 'stimulus') {\n          handleResponse(null);\n        }\n      }, 2000);\n    }, 500 + Math.random() * 500);\n  };\n\n  const handleResponse = (response) => {\n    if (phase !== 'stimulus') return;\n\n    const rt = Date.now() - startTime;\n    const correctResponse = word.toLowerCase();\n    const correct = response === correctResponse;\n    const compatible = (word.toLowerCase() === position) ? 1 : 0;\n    const status = !response ? 3 : (correct ? 1 : 2);\n\n    const result = {\n      word,\n      position,\n      compatible,\n      correctResponse,\n      response: response || 'timeout',\n      correct: correct ? 1 : 0,\n      status,\n      rt: response ? rt : 2000\n    };\n\n    setResults([...results, result]);\n    setPhase('feedback');\n\n    if (status === 1) setFeedback('âœ“');\n    else if (status === 2) setFeedback('âœ— Wrong!');\n    else setFeedback('Too slow!');\n\n    setTimeout(() => {\n      setCurrentTrial(currentTrial + 1);\n    }, status === 2 ? 1000 : 400);\n  };\n\n  return (\n    <Card className=\"w-full max-w-2xl mx-auto\">\n      <CardHeader>\n        <CardTitle>Simon Task</CardTitle>\n        <CardDescription>\n          {isTraining ? `Training Trial ${currentTrial + 1} of 5` : `Trial ${currentTrial + 1} of 24`}\n        </CardDescription>\n      </CardHeader>\n      <CardContent className=\"space-y-6\">\n        <div className=\"bg-blue-100 dark:bg-blue-900 p-3 rounded text-sm space-y-2\">\n          <p className=\"font-semibold text-center\">Respond to the WORD, ignore its position!</p>\n          <div className=\"grid grid-cols-2 gap-2 text-xs\">\n            <div className=\"bg-white dark:bg-gray-800 p-2 rounded text-center\"><kbd className=\"px-2 py-1 bg-muted rounded border font-bold\">A</kbd> for LEFT</div>\n            <div className=\"bg-white dark:bg-gray-800 p-2 rounded text-center\"><kbd className=\"px-2 py-1 bg-muted rounded border font-bold\">L</kbd> for RIGHT</div>\n          </div>\n        </div>\n\n        <div className=\"flex items-center justify-center h-64 relative border-2 border-dashed border-muted rounded\">\n          {phase === 'fixation' && <div className=\"text-6xl font-bold\">+</div>}\n\n          {phase === 'stimulus' && (\n            <div className={`absolute ${position === 'left' ? 'left-8' : 'right-8'} top-1/2 -translate-y-1/2`}>\n              <div className=\"text-5xl font-bold px-4 py-2 bg-yellow-400 text-black rounded\">{word}</div>\n            </div>\n          )}\n\n          {phase === 'feedback' && feedback && (\n            <div className={`text-3xl font-bold ${feedback.includes('âœ“') ? 'text-green-600' : 'text-red-600'}`}>{feedback}</div>\n          )}\n\n          {phase === 'stimulus' && (\n            <>\n              <div className=\"absolute left-4 top-4 text-xs text-muted-foreground\">LEFT SIDE</div>\n              <div className=\"absolute right-4 top-4 text-xs text-muted-foreground\">RIGHT SIDE</div>\n            </>\n          )}\n        </div>\n\n        {!isTraining && (\n          <div className=\"grid grid-cols-2 gap-4 text-center text-sm\">\n            <div>\n              <div className=\"text-2xl font-bold text-green-600\">{results.filter(r => r.compatible === 1 && r.correct === 1).length}</div>\n              <div className=\"text-xs text-muted-foreground\">Compatible Correct</div>\n            </div>\n            <div>\n              <div className=\"text-2xl font-bold text-blue-600\">{results.filter(r => r.compatible === 0 && r.correct === 1).length}</div>\n              <div className=\"text-xs text-muted-foreground\">Incompatible Correct</div>\n            </div>\n          </div>\n        )}\n\n        <div className=\"text-center text-xs text-muted-foreground\">{isTraining ? 'ðŸŽ“ Training Mode' : 'ðŸ“Š Main Experiment'}</div>\n      </CardContent>\n    </Card>\n  );\n};"
  },
  {
  "id": "stroop-emotion",
  "name": "Stroop + Emotions",
  "fullName": "Stroop Task with Emotion Tracking",
  "shortDescription": "Measures selective attention and cognitive control while tracking facial emotions",
  "detailedDescription": "The Stroop Task with Emotion Tracking combines the classic Stroop color-word interference task with cutting-edge real-time facial emotion recognition technology. This innovative experiment allows researchers to track how emotional states change during cognitive conflict and processing challenges.\n\nThe traditional Stroop effect demonstrates the interference that occurs when the meaning of a word (e.g., \"RED\") conflicts with the color in which it is displayed (e.g., blue). This experiment extends that paradigm by continuously monitoring participants' facial expressions throughout the task, providing insights into the emotional responses triggered by cognitive conflict.\n\n**Research Applications:**\n- Understanding emotion-cognition interactions\n- Studying stress responses during cognitive tasks\n- Clinical research in anxiety and mood disorders\n- Individual differences in emotional regulation\n\n**Technical Features:**\n- Real-time facial emotion detection using face-api.js\n- High-precision reaction time measurement\n- Comprehensive data export including emotion timeseries\n- Training trials with performance feedback",
  "duration": "~8 minutes",
  "trials": "50 trials (10 training, 40 test)",
  "difficulty": "Advanced",
  "category": "Cognitive Control",
  "measures": [
    "Selective attention",
    "Cognitive control",
    "Emotional responses",
    "Stroop effect",
    "Affect during conflict",
    "Reaction time variability"
  ],
  "icon": "Camera",
  "color": "from-indigo-500 to-purple-500",
  "requiresCamera": true,
  "keywords": [
    "stroop",
    "emotion",
    "facial recognition",
    "cognitive control",
    "attention",
    "interference"
  ],
  "researchAreas": [
    "Cognitive Psychology",
    "Affective Neuroscience",
    "Clinical Psychology"
  ],
  "publications": [
    "MacLeod, C. M. (1991). Half a century of research on the Stroop effect",
    "Ekman, P., & Friesen, W. V. (1978). Facial Action Coding System"
  ],
    
  "code": "import { useState, useEffect } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\n\nexport const SimonTemplate = ({ onComplete }) => {\n  const [currentTrial, setCurrentTrial] = useState(0);\n  const [word, setWord] = useState('');\n  const [position, setPosition] = useState('left');\n  const [phase, setPhase] = useState('fixation');\n  const [startTime, setStartTime] = useState(0);\n  const [results, setResults] = useState([]);\n  const [isTraining, setIsTraining] = useState(true);\n  const [feedback, setFeedback] = useState('');\n\n  const words = ['LEFT', 'RIGHT'];\n\n  useEffect(() => { startTrial(); }, [currentTrial]);\n\n  useEffect(() => {\n    const handleKeyPress = (e) => {\n      if (phase === 'stimulus' && (e.key === 'a' || e.key === 'l')) {\n        handleResponse(e.key === 'a' ? 'left' : 'right');\n      }\n    };\n    window.addEventListener('keydown', handleKeyPress);\n    return () => window.removeEventListener('keydown', handleKeyPress);\n  }, [phase, startTime]);\n\n  const startTrial = () => {\n    const totalTrials = isTraining ? 5 : 24;\n    if (currentTrial >= totalTrials) {\n      if (isTraining) {\n        setIsTraining(false);\n        setCurrentTrial(0);\n        return;\n      } else {\n        onComplete?.(results);\n        return;\n      }\n    }\n\n    setPhase('fixation');\n    setFeedback('');\n\n    const wordChoice = words[Math.floor(Math.random() * words.length)];\n    const posChoice = Math.random() < 0.5 ? 'left' : 'right';\n\n    setWord(wordChoice);\n    setPosition(posChoice);\n\n    setTimeout(() => {\n      setPhase('stimulus');\n      setStartTime(Date.now());\n      setTimeout(() => {\n        if (phase === 'stimulus') {\n          handleResponse(null);\n        }\n      }, 2000);\n    }, 500 + Math.random() * 500);\n  };\n\n  const handleResponse = (response) => {\n    if (phase !== 'stimulus') return;\n\n    const rt = Date.now() - startTime;\n    const correctResponse = word.toLowerCase();\n    const correct = response === correctResponse;\n    const compatible = (word.toLowerCase() === position) ? 1 : 0;\n    const status = !response ? 3 : (correct ? 1 : 2);\n\n    const result = {\n      word,\n      position,\n      compatible,\n      correctResponse,\n      response: response || 'timeout',\n      correct: correct ? 1 : 0,\n      status,\n      rt: response ? rt : 2000\n    };\n\n    setResults([...results, result]);\n    setPhase('feedback');\n\n    if (status === 1) setFeedback('âœ“');\n    else if (status === 2) setFeedback('âœ— Wrong!');\n    else setFeedback('Too slow!');\n\n    setTimeout(() => {\n      setCurrentTrial(currentTrial + 1);\n    }, status === 2 ? 1000 : 400);\n  };\n\n  return (\n    <Card className=\"w-full max-w-2xl mx-auto\">\n      <CardHeader>\n        <CardTitle>Simon Task</CardTitle>\n        <CardDescription>\n          {isTraining ? `Training Trial ${currentTrial + 1} of 5` : `Trial ${currentTrial + 1} of 24`}\n        </CardDescription>\n      </CardHeader>\n      <CardContent className=\"space-y-6\">\n        <div className=\"bg-blue-100 dark:bg-blue-900 p-3 rounded text-sm space-y-2\">\n          <p className=\"font-semibold text-center\">Respond to the WORD, ignore its position!</p>\n          <div className=\"grid grid-cols-2 gap-2 text-xs\">\n            <div className=\"bg-white dark:bg-gray-800 p-2 rounded text-center\"><kbd className=\"px-2 py-1 bg-muted rounded border font-bold\">A</kbd> for LEFT</div>\n            <div className=\"bg-white dark:bg-gray-800 p-2 rounded text-center\"><kbd className=\"px-2 py-1 bg-muted rounded border font-bold\">L</kbd> for RIGHT</div>\n          </div>\n        </div>\n\n        <div className=\"flex items-center justify-center h-64 relative border-2 border-dashed border-muted rounded\">\n          {phase === 'fixation' && <div className=\"text-6xl font-bold\">+</div>}\n\n          {phase === 'stimulus' && (\n            <div className={`absolute ${position === 'left' ? 'left-8' : 'right-8'} top-1/2 -translate-y-1/2`}>\n              <div className=\"text-5xl font-bold px-4 py-2 bg-yellow-400 text-black rounded\">{word}</div>\n            </div>\n          )}\n\n          {phase === 'feedback' && feedback && (\n            <div className={`text-3xl font-bold ${feedback.includes('âœ“') ? 'text-green-600' : 'text-red-600'}`}>{feedback}</div>\n          )}\n\n          {phase === 'stimulus' && (\n            <>\n              <div className=\"absolute left-4 top-4 text-xs text-muted-foreground\">LEFT SIDE</div>\n              <div className=\"absolute right-4 top-4 text-xs text-muted-foreground\">RIGHT SIDE</div>\n            </>\n          )}\n        </div>\n\n        {!isTraining && (\n          <div className=\"grid grid-cols-2 gap-4 text-center text-sm\">\n            <div>\n              <div className=\"text-2xl font-bold text-green-600\">{results.filter(r => r.compatible === 1 && r.correct === 1).length}</div>\n              <div className=\"text-xs text-muted-foreground\">Compatible Correct</div>\n            </div>\n            <div>\n              <div className=\"text-2xl font-bold text-blue-600\">{results.filter(r => r.compatible === 0 && r.correct === 1).length}</div>\n              <div className=\"text-xs text-muted-foreground\">Incompatible Correct</div>\n            </div>\n          </div>\n        )}\n\n        <div className=\"text-center text-xs text-muted-foreground\">{isTraining ? 'ðŸŽ“ Training Mode' : 'ðŸ“Š Main Experiment'}</div>\n      </CardContent>\n    </Card>\n  );\n};"
  },
  {
  "id": "pupil-gaze-reaction",
  "name": "Gaze-Target Reaction",
  "fullName": "Pupil-Tracked Visual Attention & Orienting Task",
  "shortDescription": "Measures visual attention and covert orienting using pupil/gaze tracking",
  "detailedDescription": "The Gaze-Target Reaction Task is an innovative web-based experiment that uses real-time pupil and iris tracking via TensorFlow.js (MediaPipe FaceMesh) to measure visual attention and orienting speed without requiring manual responses. This paradigm represents a significant advancement in cognitive testing by enabling eye-tracking research directly in the browser.\n\n**How It Works:**\nParticipants first complete a 5-point calibration procedure that maps pupil coordinates in the video frame to screen coordinates. During trials, targets (circles) appear at random calibrated positions on the screen. The system continuously tracks where the participant is looking and automatically detects when their gaze lands on and remains on the target for at least 150ms (sustained fixation). This measures covert attention - the ability to shift attention without moving the eyes initially, followed by the saccade to the target.\n\n**Technical Innovation:**\nAll processing happens entirely in the browser using TensorFlow.js with the MediaPipe FaceMesh model (with predictIrises: true). The system computes:\n- Pupil center coordinates (x, y in video pixels)\n- Pupil radius (for tracking dilation)\n- Eye bounding boxes\n- Normalized gaze coordinates (mapped to screen using calibration)\n- High-resolution timestamps (performance.now())\n\n**Calibration Procedure:**\nThe 5-point calibration shows dots at:\n1. Top-left corner\n2. Top-right corner\n3. Center\n4. Bottom-left corner\n5. Bottom-right corner\n\nFor each point, 30 frames of pupil data are collected and averaged to create a robust mapping. The system uses affine transformation or bilinear interpolation to convert video-space coordinates to screen-space coordinates. Visual feedback shows calibration quality, and participants can recalibrate if jitter exceeds threshold.\n\n**Privacy & Ethics:**\nNo video frames are recorded or transmitted. Only derived metrics (pupil coordinates, radius, gaze position, timestamps) are stored. Explicit consent is required before camera access. All machine learning inference runs locally - no data sent to external ML services.\n\n**Research Applications:**\n- Visual attention and orienting speed assessment\n- Covert vs overt attention mechanisms\n- Saccade latency measurement\n- Pupil dilation as cognitive load indicator\n- Individual differences in visual processing\n- Clinical assessment (ADHD, autism spectrum, neurological conditions)\n- Usability testing and human-computer interaction\n\n**Fallback Mechanism:**\nIf camera access is denied or unavailable, participants can complete a keyboard-based version where they press keys to indicate target detection, maintaining experimental validity while accommodating all users.\n\n**Advantages Over Traditional Eye Trackers:**\n- No specialized hardware required\n- Accessible remotely\n- Scalable for large-scale studies\n- Cost-effective\n- Platform-independent (works on any device with webcam)\n\n**Data Quality:**\nWhile webcam-based tracking has lower precision than dedicated eye trackers (Â±50-100px vs Â±10-20px), it's sufficient for measuring gross gaze behavior, saccade latency, and sustained attention - the primary outcomes of this task.",
  "duration": "~5-7 minutes",
  "trials": "15 trials + 5-point calibration",
  "difficulty": "Advanced",
  "category": "Attention & Perception",
  "measures": [
    "Visual orienting speed",
    "Covert attention",
    "Gaze accuracy",
    "Pupil dilation",
    "Saccade latency",
    "Fixation stability",
    "Gaze-target detection time"
  ],
  "keywords": [
    "pupil tracking",
    "gaze",
    "eye tracking",
    "visual attention",
    "orienting",
    "covert attention",
    "TensorFlow.js",
    "MediaPipe",
    "iris detection",
    "saccade",
    "fixation",
    "webcam eye tracking",
    "browser-based tracking",
    "facemesh",
    "pupil dilation"
  ],
  "requiresCamera": true,
  "icon": "Eye",
  "color": "from-purple-500 to-blue-500",
  "code": "import React, { useState, useEffect } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { Camera, Eye, Target } from 'lucide-react';\n\nexport const PupilGazeReactionTemplate = ({ onComplete }) => {\n  const [phase, setPhase] = useState('consent');\n  const [results, setResults] = useState([]);\n  \n  const handleStart = async () => {\n    try {\n      await navigator.mediaDevices.getUserMedia({ video: true });\n      setPhase('experiment');\n    } catch (error) {\n      alert('Camera access required');\n    }\n  };\n  \n  if (phase === 'consent') {\n    return (\n      <Card className=\"max-w-2xl mx-auto\">\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\"><Eye className=\"w-6 h-6\" />Gaze Tracking Experiment</CardTitle>\n          <CardDescription>Requires camera for pupil tracking</CardDescription>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <Alert><Camera className=\"h-4 w-4\" /><AlertDescription>Camera access required. All processing happens locally.</AlertDescription></Alert>\n          <Button onClick={handleStart} className=\"w-full\"><Camera className=\"w-4 h-4 mr-2\" />Enable Camera & Start</Button>\n        </CardContent>\n      </Card>\n    );\n  }\n  \n  return <div className=\"text-center p-8\"><Target className=\"w-12 h-12 mx-auto mb-4\" /><p>Experiment running...</p></div>;\n};"
  }
]
